USAGE:

makeexm [options] <.exm file> [<.map file>]

PURPOSE:

This command converts a suitably-written .EXE file into a .EXM file.

OPTIONS:

Option names always start with a single dash ("-") and must be spelled
exactly as shown but may be entered in upper, lower, or mixed case.
No embedded spaces may be used in the option name.  Note that many
options also have a "short" form.  If an option has a parameter, the
parameter must be separated from the option name with one or more
space or tab characters.  Option names or option name/parameter pairs
may appear anywhere in the command line after the command name.

	-f <file(s)>
	The program does no conversion.  Instead, it prints out the
	number of fixups in each of the specified files.

	Note that the program does not check whether the file is
	really a .EXE or .EXM file.  If you supply it with the name of
	a non-.EXE and non-.EXM file, it will print a meaningless
	number.

	-t
	Patches the far calls in the executable.  See the description.


RESTRICTIONS:

none.

DEFAULTS:

The <.map file> defaults to the same file as the <.exm file>.

FUNCTION:

The first parameter gives the name of a .EXE file that will be
converted in place to a .EXM file.  If you don't enter a suffix, the
program will assume ".EXM".  The second parameter is optional, and
specifies the name of the .MAP file that goes with the .EXE file.  If
you omit the parameter, the first parameter is used.  In any case, the
extension is forced to ".MAP".

This program differs from HP's E2M in three major ways.  First, it
converts the file in place (and is thus much faster).  Second, it
supports both Microsoft and Borland .MAP file formats.  Third, it
prints the number of fixups in the converted program, so that you can
see if you have any problems.

The -p option tells MAKEEXM to "patch out" all fixups.

Why is this necessary?  I was able to write MemUtil in such a way that
no fixups were generated by the compiler.  However, Freyja uses long
(32-bit) integer arithmetic in many places and, for no reason that I
can discern, Borland's Turbo C V2.0 always generates FAR calls to the
"helper" routines that do the 32-bit arithmetic.  Each such FAR call
generates a fixup.

Now, a system-manager compliant application must have a code segment
that is no more than 64 KBytes long.  Hence, all such FAR calls could
be converted to NEAR calls.  It would be nice if the compiler handled
this, but it doesn't.  MAKEEXM does this conversion.  Each fixup is
patched as follows:

In the .EXM file, the call looks like this:

	0x9A LOW HIGH 0x00 0x00
	               ^

The 0x9A is the code for a FAR CALL instruction.  The LOW and HIGH
values specify the offset to call.  The top two bytes are always zero,
as our code segment is less than 64 KBytes (in other uses, these
values need not be zero, but they always will be for an application).
The fixup entry points to the place marked with a carat.  The MAKEEXM
program changes these five bytes to the following:

	0xE8 _nearfar LOW HIGH

The 0xE8 is the code for a NEAR CALL instruction.  _nearfar is the
address of (actually, relative distance to) a special routine.  LOW
and HIGH are the same values as before, just moved by two bytes.

In summary, we started with a FAR call to a routine.  We wound up with
a NEAR call to a special helper routine, with the address of the
desired routine in a convenient spot.

AUTHOR:

Copyright 1992,3 by Craig A. Finseth
